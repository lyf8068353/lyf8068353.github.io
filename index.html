<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>UGUI表情系统解决方案 by lyf8068353</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">UGUI表情系统解决方案</h1>
      <h2 class="project-tagline">UGUI表情系统解决方案</h2>
    </section>

    <section class="main-content">
      <p>Unity推荐的方式是使用TextMesh解决混编问题。TextMesh的确可以实现混编，但是却存在和UGUI较难整合的问题（Mask遮罩、自适应等），同时也会因为使用多个材质导致无法使用动态批次合并。网上也有人使用Text+Image的形式来处理图文混编，但是需要解决排序等问题。最好的解决方案还是能让UGUI的Text能够自身支持图文混编。
通过查看UGUI的源代码和其Shader，可以重写Text生成Mesh的方法以及最终渲染的Shader，以此来实现图文混编的功能，后文会为大家一步步介绍实现方法。</p>

<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating pages manually<img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HDzemqUwYyPLvo93V91nc0WvFExMicprGrW9CjRZ68ohwwNemo0bOBg2YEoRDHEfS50SDg4J3N2a2A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">
</h3>

<p>这是原始的表情资源，按照表情名_序列帧的形式统一命名，然后通过代码打成一张Atlas，为了能够支持动态表情，需要在Shader中使用UV动画，但是因为所有的表情都在一张Atlas中，帧数又不统一，因此需要再生成一张可以标识每一个表情有多少帧的数据贴图。
表情和数据Atlas，这两张图片会在最终渲染的Shader中使用。
<img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HB1h0IvibN09wxic2ibhfiaXT4ZdnIynZGfyILoibQ6l6UicLIP97bcc9hqUoK53uILQwuUSbBtkGa2MiaSw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">
当然还需要生成一张数据表，用户标识表情名和Text替代符的对应关系，以及每一个表情的UV位置。其中Key中的内容就是在Text中的表情替代符，至于为什么使用这种格式会在后面内容介绍。</p>

<p>这是比较关键的步骤，UGUI中Text生成顶点的规律是每个字符生成4个顶点，构成2个面。例如字符串：这是一个Text，在UGUI中会生成8x4=32个顶点，中文、英文、其他字符都是等价的，只是顶点之间的间距不同。因此可以在将表情替代符中的多个顶点修改成适合表情的4个顶点，使用第二套UV标识这部分顶点引用表情贴图，而非字体贴图。例如一个字符串：这里是表情[0]。在生成顶点的时候利用正则找到字符串中的表情替代符，将这部分顶点做处理，并写入配表中的UV坐标到第二纹理坐标。经过测试[0]或[01]这个字符的顶点间距比较适合放置一张表情，因此使用[字符]和[字符字符]的形式做表情替代符。为了能让两个字符位置能够表示更多的表情，每个字符可以使用A-Z，a-z，0-9，总共62个字符，最终也就是3844个表情，足够应付游戏的需求。</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HDzemqUwYyPLvo93V91nc0WD45722ZicSF9faKxiaY1CzByXk34XyFHpLToEEQerfYU0IAogeXuIhrw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>读取配置文件，用于后面替换表情符。</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HDzemqUwYyPLvo93V91nc0W3vlcThaKjibhvicBBpfpsjfHhCFNiaRJiajicRibzOk31sZLDxOc3Qs2zRzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HDzemqUwYyPLvo93V91nc0W3vlcThaKjibhvicBBpfpsjfHhCFNiaRJiajicRibzOk31sZLDxOc3Qs2zRzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>利用正则表达式找出全部的表情符，并且匹配是否为系统所支持的表情符（上面读取的配置文件）。</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HDzemqUwYyPLvo93V91nc0W3k005mWMmv4yFDW1r8GMKzJNPX4YaYDEQ3SexRRwS6Dm5dyJIUQM8w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>重新生成顶点位置和UV坐标。</p>

<p>重写渲染部分</p>

<p>这是最后一步，重写一个Shader用来渲染。相较于原始Shader增添了几个新的属性。</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HB1h0IvibN09wxic2ibhfiaXT4ZHiaQEJ05wAVlwAr2oVY58b822Tiazqpx9CRLezz1ufFffyxwdnibYNavA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>其中_EmojiSize表示EmojiTexture每一行拥有几个表情，因为本示例中每一行有4个表情，所以这个位置填写</p>

<p>4。其他的属性就不做阐述了
<img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HB1h0IvibN09wxic2ibhfiaXT4ZwwAicOJUozo5HyMSmia6bm3dWM6NabwUuL2ABmajiaxyrupGVHAv9Xgfw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>引入第二套uv坐标。
<img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HB1h0IvibN09wxic2ibhfiaXT4Zqtvr0mpKQpCmbNeXJhQ7lFWXv1DbSeD9bFyh4NV8lmZhxwAhc73g1Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>VS几乎没多大变化，只是传递第二套UV坐标。
<img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HB1h0IvibN09wxic2ibhfiaXT4Zc2jaPXkdvok2GQia5bYuGHdFJr5jEuZd7KicpAC9icvXCMXgao1y4uSgA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>PS中先判断第二套UV坐标是否有数值，有数值则表明是表情，从_EmojiTex中绘制，从_EmojiDataTex中读取表情帧数，用于做uv动画。
<img src="http://mmbiz.qpic.cn/mmbiz_png/ALp6MpyX3HDzemqUwYyPLvo93V91nc0WchoNFyhUBcxuGDGzn5C1VZs5mF4f6iaQPQQZJxXecI5godNpudkiaUlQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>

<p>至此，就实现了UGUI的表情系统，可以和原生的其他UGUI控件使用。同时因为只有一个材质，一个Pass，所以也可以进行动态批次合并。</p>

<p>工程代码笔者以上传到自己的Github中，<a href="https://github.com/zouchunyi/EmojiText%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6Clone%E3%80%82">https://github.com/zouchunyi/EmojiText，欢迎大家Clone。</a></p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
